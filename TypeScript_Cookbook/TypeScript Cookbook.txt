TypeScript Cookbook
by Stefan Baumgartner


github TypeScript Cookbook Stefan Baumgartner
github "TypeScript Cookbook" Stefan Baumgartner
https://typescript-cookbook.com/
https://typescript-cookbook.com/examples/

https://www.oreilly.com/library/view/typescript-cookbook/9781098136642/
https://www.oreilly.com/library/view/typescript-cookbook/9781098136642/ch04.html


2. Basic Types

    2.1. Annotating Effectively
    2.2. Working with any and unknown
    2.3. Choosing the Right Object Type
    2.4. Working with Tuple Types
    2.5. Understanding Interfaces Versus Type Aliases
    2.6. Defining Function Overloads
    2.7. Defining this Parameter Types
    2.8. Working with Symbols
    2.9. Understanding Value and Type Namespaces

3. The Type System

    3.1. Modeling Data with Union and Intersection Types
    3.2. Explicitly Defining Models with Discriminated Union Types
    3.3. Exhaustiveness Checking with the Assert never Technique
    3.4. Pinning Types with Const Context
    3.5. Narrowing Types with Type Predicates
    3.6. Understanding void
    3.7. Dealing with Error Types in catch Clauses
    3.8. Creating Exclusive Or Models with Optional never
    3.9. Effectively Using Type Assertions
    3.10. Using Index Signatures
    3.11. Distinguishing Missing Properties and Undefined Values
    3.12. Working with Enums
    3.13. Defining Nominal Types in a Structural Type System
    3.14. Enabling Loose Autocomplete for String Subsets

4. Generics

    4.1. Generalizing Function Signatures
    4.2. Creating Related Function Arguments
    4.3. Getting Rid of any and unknown
    4.4. Understanding Generic Instantiation
    4.5. Generating New Object Types
    4.6. Modifying Objects with Assertion Signatures
    4.7. Mapping Types with Type Maps
    4.8. Using ThisType to Define this in Objects
    4.9. Adding Const Context to Generic Type Parameters

5. Conditional Types

    5.1. Managing Complex Function Signatures
    5.2. Filtering with never
    5.3. Grouping Elements by Kind
    5.4. Removing Specific Object Properties
    5.5. Inferring Types in Conditionals

6. String Template Literal Types

    6.1. Defining a Custom Event System
    6.2. Creating Event Callbacks with String Manipulation Types and Key Remapping
    6.3. Writing a Formatter Function
    6.4. Extracting Format Parameter Types
    6.5. Dealing with Recursion Limits
    6.6. Using Template Literals as Discriminants

7. Variadic Tuple Types

    7.1. Typing a concat Function
    7.2. Typing a promisify Function
    7.3. Typing a curry Function
    7.4. Typing a Flexible curry Function
    7.5. Typing the Simplest curry function
    7.6. Creating an Enum from a Tuple
    7.7. Splitting All Elements of a Function Signature

8. Helper Types

    8.1. Setting Specific Properties Optional
    8.2. Modifying Nested Objects
    8.3. Remapping Types
    8.4. Getting All Required Keys
    8.5. Allowing at Least One Property
    8.6. Allowing Exactly One and All or None
    8.7. Converting Union to Intersection Types
    8.8. Using type-fest

9. The Standard Library and External Type Definitions

    9.1. Iterating over Objects with Object.keys
    9.2. Explicitly Highlighting Unsafe Operations with Type Assertions and unknown
    9.3. Working with defineProperty
    9.4. Expanding Types for Array.prototype.includes
    9.5. Filtering Nullish Values
    9.6. Extending Modules
    9.7. Augmenting Globals
    9.8. Adding Non-JS Modules to the Module Graph

10. TypeScript and React

    10.1. Writing Proxy Components
    10.2. Writing Controlled Components
    10.3. Typing Custom Hooks
    10.4. Typing Generic forwardRef Components
    10.5. Providing Types for the Context API
    10.6. Typing Higher-Order Components
    10.7. Typing Callbacks in Reactâ€™s Synthetic Event System
    10.8. Typing Polymorphic Components

11. Classes

    11.1. Choosing the Right Visibility Modifier
    11.2. Explicitly Defining Method Overrides
    11.3. Describing Constructors and Prototypes
    11.4. Using Generics in Classes
    11.5. Deciding When to Use Classes or Namespaces
    11.6. Writing Static Classes
    11.7. Working with Strict Property Initialization
    11.8. Working with this Types in Classes
    11.9. Writing Decorators

12. Type Development Strategies

    12.1. Writing Low Maintenance Types
    12.2. Refining Types Step by Step
    12.3. Checking Contracts with satisfies
    12.4. Testing Complex Types
    12.5. Validating Data Types at Runtime with Zod
    12.6. Working Around Index Access Restrictions
    12.7. Deciding Whether to Use Function Overloads or Conditional Types
    12.8. Naming Generics
    12.9. Prototyping on the TypeScript Playground
    12.10. Providing Multiple Library Versions
    12.11. Knowing When to Stop



interface HTMLElementTagNameMap {
	[x: string]: HTMLUnknownElement;
};



function createElement<T extends keyof AllElements>(tag: T, props?: ): AllElements<T>



DOM NodeList



Distributive Conditional Type
Ch 8.5 or 8.6 Naked types in Conditional types
With a Naked type , a Conditional of union types becomes a union of Conditional types




DeepPartial



Debug
Simplify
type Remap<T> = {
	[K in keyof T]: T[K];
};



type DeepRemap<T> = T extends object
	? {
		  [K in keyof T]: DeepRemap<T[K]>;
	  }
	: T;


